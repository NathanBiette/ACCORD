function [x, compteur]=mixte_resolution(V, W, H, beta, epsilon)compteur = 1;C = transpose(W)*W;if det(C) ~= 0    Winv = C\transpose(W);else     Winv = transpose(zeros(size(W)));end;Vprim = W*H;for i=1:length(V)    if Vprim(i) < V(i)        x = Winv*V;        return;    end;end;A = transpose(W)*(((W*H).^(beta-2)).*V);B = transpose(W)*((W*H).^(beta-1));x = A./B;J = ones([length(x) 1]);while sqrt(sum((x-J).^2))>epsilon    H = H.*x;        Vprim = W*H;    for i=1:length(V)        if Vprim(i) < V(i)           H = Winv*V;           break;        end;    end;        A = transpose(W)*(((W*H).^(beta-2)).*V);    B = transpose(W)*((W*H).^(beta-1));    x = A./B;        % Utiliser min(x) s'est trouvé empiriquement préférable à max    %if max(x) > 1    %    x = ones(length(x))./x;    %end;        %    %for i=1:length(x)    %    if x(i) > 1    %        x(i) = 1/x(i);    %    end;    %end;            % cette boucle n'est jamais appelée lorsqu'on rajoute     % la boucle if ci-dessus    compteur = compteur + 1;    if compteur > 1000        break;    end;end; H = H.*x;x = H;% on ne sait pas pourquoi mais ça renvoit toujours compteur = 2 ou 1return;end